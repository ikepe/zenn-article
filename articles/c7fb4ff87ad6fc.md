---
title: "PURL：ソフトウェアサプライチェーンを守る「共通言語」"
emoji: "🔗"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["purl", "sbom", "脆弱性管理", "security", "ソフトウェアサプライチェーン"]
published: false
---

この記事は[脆弱エンジニアのアドベントカレンダー](https://qiita.com/advent-calendar/2025/full-weak-engineer)19日目の記事です。

:::message
この記事は生成AIを活用し画像生成・文章作成を行っています。
:::

## PURLとは何か

PURL（Package URL）は、さまざまなソフトウェアパッケージを統一的に識別するための仕組みです。これらは一貫性に欠け、たとえばnpm、Maven、PyPIなど異なるエコシステム間で同じパッケージを識別する統一的な方法がなく、ツール間での相互運用性が低いという課題がありました。PURLはこの問題を解決するために設計され、パッケージの種類、名前、バージョン、名前空間などの情報を含む標準化されたURL形式でパッケージを表現します。これにより、異なるツールやエコシステム間でパッケージを一意に識別し、依存関係の解析や脆弱性管理などのタスクを効率化できます。
概要を以下に示します。

![](/images/c7fb4ff87ad6fc/NBLM_1.png)
*NotebookLMを利用し作成*

PURLは、ソフトウェア部品表（SBOM: Software Bill of Materials）や脆弱性管理において重要な役割を果たします。


## PURLの仕様詳細

### 構成要素（7コンポーネント）
PURLは以下の7つのコンポーネントで構成されます。

```
  scheme:type/namespace/name@version?qualifiers#subpath
```
*：必須項目
| コンポーネント | 説明 | 例 |
| ---- | ---- | ---- |
| scheme* | 固定値 "pkg" | `pkg` |
| type* | パッケージのエコシステムやタイプ | `npm`, `maven`, `pypi`, `deb` など |
| namespace | パッケージの名前空間 | `org.apache.logging.log4j` <br> `@types`（%40types） |
| name* | パッケージ名 | `express`, `commons-lang3`, `requests`, `xz` など |
| version | パッケージのバージョン | `5.8.1` など |
| qualifiers | 追加の識別情報 | OS、アーキテクチャ、ビルド情報など <br> `arch=amd64&distro=debian-12` |
| subpath | パッケージ内の特定のファイルやディレクトリへのパス | `src/index.js` など |
- PURLはASCII文字列で、区切り文字や特殊文字は パーセントエンコードされます <br>（例：`@types` → `%40types`）。
- qualifiers は “メタデータを何でも詰め込む場所” ではなく、同一性の判定に必要な最小限に留める必要があります。

### 具体例

手元のmacOS環境で、Homebrewによりインストールした xz（5.8.1）を例にします。Homebrewはインストール済みFormulaのディレクトリに SPDX形式のSBOM（sbom.spdx.json）を含む場合があり、その中にPURLが記載されます。

```json:/opt/homebrew/Cellar/xz/5.8.1/sbom.spdx.json
{
  "packages": [
    {
      "SPDXID": "SPDXRef-Bottle-xz",
      "name": "xz",
      "versionInfo": "5.8.1",
      "externalRefs": [
        {
          "referenceCategory": "PACKAGE-MANAGER",
          "referenceLocator": "pkg:brew/homebrew/core/xz@5.8.1",
          "referenceType": "purl"
        }
      ]
    }
  ]
}
```

### 対応エコシステム一覧

対応エコシステムは以下のJSONファイルにまとめられています。

https://github.com/package-url/purl-spec/blob/main/purl-types-index.json

type がどうしても当てはまらない場合は`generic`を使用できますが、可能な限りより具体的なtype（OSパッケージなら deb / rpm、言語なら npm / pypi / maven など）を選ぶ方が、ツール間での一致判定が安定します。

## PURL以外の識別子
### CPE（Common Platform Enumeration）
NVD（National Vulnerability Database）などで、脆弱性の影響を受ける“製品/プラットフォーム”を表すために使われる識別子です。CVEの「Affected Products」を表現する文脈で登場することが多いです。

```
cpe:2.3:{種別}:{ベンダ}:{製品}:{バージョン}:{更新}:{エディション}:{言語}:{ソフトウェア版}:{対象ソフトウェア}:{対象ハードウェア}:{その他}
```
種別：a（アプリ）/ o（OS）/ h（ハード）
*：任意（Any）、-：該当なし（NA）

例えばXZ version 5.8.1の場合以下のようになります。

```:CPE例（xz 5.8.1）
cpe:2.3:a:tukaani:xz:5.8.1:*:*:*:*:*:*:*
```

| 項目 | 例 | 
| ---- | ---- | 
| 種別 | a：アプリケーション | 
| ベンダ名 | tukaani | 
| 製品名 | xz | 
| バージョン | 5.8.1 | 
| その他 | *：全て |

その他略称や予約文字もあります。

:::message
CPEは「製品名の表記ゆれ」や「どの粒度を製品と見なすか」でマッチングが難しくなることがあります（特にOSSパッケージ単位）。
:::

### SWID（Software Identification Tag）
SWIDは、ISO/IEC 19770-2:2015 に準拠した ソフトウェア識別タグ（XML） です。
CPEが「製品名の表現」に寄るのに対し、SWIDは インストール済み/配布物としての“実体”を表す名札として使いやすいのが特徴です。


```xml:SWIDタグ例（xz 5.8.1）
<?xml version="1.0" encoding="UTF-8"?>
<SoftwareIdentity xmlns="http://standards.iso.org/iso/19770/-2/2015/schema.xsd"
  xml:lang="en"
  name="xz"
  version="5.8.1"
  tagId="org.tukaani.xz-5.8.1"
  tagVersion="1">
  <Entity name="Tukaani Project" regid="tukaani.org" role="softwareCreator"/>
  <Entity name="Homebrew" regid="brew.sh" role="tagCreator distributor"/>
  <Link rel="homepage" href="https://tukaani.org/xz/"/>
</SoftwareIdentity>
```

### 3つの識別子の比較

PURL / CPE / SWID は、「何を同定したいか（粒度）」と「何に使うか（目的）」で使い分けます。

**PURL**
依存関係の解析やSBOMで扱う “パッケージ” を識別するのに向く
例：Homebrew, npm, Maven, PyPI などのエコシステムで流通する単位

**CPE**
CVE/NVD 等での脆弱性情報と突合しやすい “製品（プラットフォーム）” の表現に向く
例：OS、商用ソフト、ミドルウェアなど「製品名」で扱われる対象

**SWID**
端末や環境に存在する “インストール済みソフトの実体” を、配布者・作成者・（必要なら）構成ファイルまで含めて表現するのに向く

| 使用法 | PURL | CPE | SWID |
| ---- | ---- | ---- | ---- |
| クライアント/サーバ アプリケーション |  | ○ | ○ |
| コンテナ | ○ |  | ○ |
| ファームウェア |  | ○ | ○ |
| ライブラリ / フレームワーク（パッケージ）| ○ |  |  |
| ライブラリ / フレームワーク (パッケージ以外) |  |  | ○ |
| OS |  | ○ | ○ |
| OS (パッケージ) | ○ |  | ○ |



## なぜPURLが注目されているのか（サプライチェーン攻撃の現実）

昨今、PURL（Package URL）がこれほど注目されているのは、ソフトウェアサプライチェーン攻撃が「他人事」ではなくなってきたからです。攻撃の手口は巧妙化し、依存パッケージからCI/CD、認証情報までが狙われる今、もはや人手で影響範囲を追うのは限界に来ています。そこで鍵となるのが、「自分たちの環境にあるもの」と「攻撃されたもの」を、ツールをまたいで正確に、かつ一瞬で突き合わせる仕組みです。この橋渡し役こそが、SBOMとPURLなのです。

具体的にどのような脅威があるのか、最近の代表的な2つの事例を取り上げます。

---

### 事例1：XZ Utils（CVE-2024-3094）— “長期潜伏型”のOSS侵害

2024年3月にXZ Utilsに悪意のあるコードが挿入された問題（CVE-2024-3094）が発覚しました。
このツールは、複数のLinuxディストリビューションなどで利用されているファイル圧縮ツールです（Debianでは `xz-utils`、Fedora/RHELでは `xz` など、ディストリビューションごとにパッケージ名や管理体系が異なります）。2023年頃からOSSプロジェクトに携わってきたJia Tanという人物が、長期間にわたり正規のメンテナとして振る舞いながらバックドアを仕込んでいました。
本件はリリース前に発覚したため、大規模な被害には至りませんでしたが、仮に発覚が遅れていた場合、影響は甚大なものになっていた可能性があります。

![](/images/c7fb4ff87ad6fc/Gemini_3.png)
*Google Geminiを利用し作成*


### 事例2：Shai-Hulud（Sha1-Hulud）系キャンペーン— npm汚染と“認証情報ワーム化”

2025年、npmエコシステムは「Shai-Hulud」と呼ばれる自己増殖型ワームにより、その信頼モデルを根本から揺るがされました。9月に発生したv1は、メンテナの認証情報を窃取し、post-installスクリプトを通じて数百のパッケージへ感染を広げました。しかし、11月に観測されたv2（The Second Coming）は戦術を劇的に進化させ、セキュリティスキャンが走る前のpre-install段階での実行や、活動隠蔽のための破壊的ワイパー（デッドマンスイッチ）を実装しました。結果として、わずか数日で25,000以上のリポジトリが汚染される事態となりました。

この一連の攻撃は、現代のソフトウェア開発が抱える「深く複雑な依存関係の不透明さ」を浮き彫りにしました。信頼していたライブラリが自動更新によって突如マルウェア化し、開発環境そのものを攻撃する現状において、開発者が自身のソフトウェアに含まれる全コンポーネントを目視で把握することは不可能です。このような状況では、SBOMに記載されたPURLを基に「どのバージョンが汚染されたか」を機械的に突合し、影響範囲を瞬時に特定できることが致命的な差を生みます。

![](/images/c7fb4ff87ad6fc/NBLM_4.png)
*NotebookLMを利用し作成*

### これらの攻撃に対するSBOM+PURLの役割

上記の事例から明らかになるのは、「何が入っているか分からない」状態こそが最大のリスクということです。XZ Utilsでは「本当にxz 5.6.1が入っているのか？」、Shai-Huludでは「汚染されたパッケージがどこまで広がったか？」を迅速に特定できなければ、対処は後手に回ります。

#### なぜSBOMが必要なのか

SBOMは「構成部品のリスト」です。従来の手動での棚卸しでは、以下のような問題がありました

- そもそも、どの環境に何が入っているか調べるだけで数日かかる
- 「直接入れた覚えのないライブラリ」がどこに潜んでいるか追えない
- 開発・本番環境でバージョンが微妙にズレていても、誰も気づけない

SBOMを導入することで、以下のメリットが得られます。

**1. 影響範囲を即座に特定**
- 脆弱性情報（CVEなど）が公開された瞬間、「自社のどの環境にxz 5.6.0/5.6.1が入っているか」を数秒で列挙可能
- Shai-Huludのような自己増殖型攻撃では、汚染パッケージが検出された瞬間、依存ツリー全体を遡って影響を評価できる

**2. サプライチェーン全体の可視化**
- 開発環境に何が入っているかをリアルタイムで把握
- CI/CDパイプラインでの自動チェックが可能
- 信頼していたライブラリが自動更新によって突如マルウェア化しても、変更を検知できる

#### なぜPURLが重要なのか

しかし、SBOM（部品表）があるだけでは不十分です。各ツールが独自の形式でパッケージを記録していては、情報を突き合わせることができないからです。パッケージを一意に識別できなければ、SBOMは「曖昧なリスト」に過ぎません。

従来、脆弱性管理ではCPE（Common Platform Enumeration）が使われてきましたが、これはOS・ハードウェア向けに設計されており、現代の高速なライブラリ更新や複雑な依存関係を表現しきれませんでした。一方PURLは、開発者が日常的に使うパッケージマネージャ（npm、pip、Mavenなど）の構造をそのまま反映しているため、ツール間での互換性が極めて高く、エコシステムの実態に即した識別が可能です。ここでPURLが重要になります。

**1. 主要なSBOM標準での採用**
PURLはその有用性から、主要なSBOMフォーマットで標準的な識別子として採用されています。
- **CycloneDX**: パッケージ識別子としてPURLをネイティブにサポートしており、利用が推奨されています。
- **SPDX**: 外部リファレンス（External Reference）としてPURLを記述でき、他ツールとの連携の要となっています。

**2. エコシステム横断での一貫した識別**
Homebrew版のxz、Debian apt版のxz、ソースからビルドしたxzは、従来異なる管理体系でした。PURLなら：
- `pkg:brew/homebrew/core/xz@5.8.1`
- `pkg:deb/debian/xz-utils@5.4.1-0.2?arch=amd64&distro=debian-12`

のように統一フォーマットで表現でき、「どのエコシステムから入ったものか」まで追跡可能になります。

**3. 脆弱性情報との機械的な突合**
CVE情報に含まれるパッケージ識別子とSBOM内のPURLを自動照合することで：
- 「このCVEは自社に影響があるか？」を手動確認なしで判定
- 複数のツール（SCA、脆弱性スキャナ、SBOMビューアなど）間でブレのない一致判定

**4. パッケージの「住所録」としての役割**
PURLは単なる名前ではなく、パッケージの出自（エコシステム、名前空間、バージョン）を含む「完全な住所」です。これにより：
- 名前の表記ゆれ（`xz` vs `xz-utils` vs `XZ Utils`）に惑わされない
- 同名の別パッケージ（typosquatting攻撃）を区別できる

さらに、PURLは人間が見ても直感的に理解できる形式です：
- `pkg:npm/left-pad@1.3.0`
- `pkg:pypi/requests@2.25.1`

このパッと見の分かりやすさが、インシデント対応時のチーム間コミュニケーションミスを減らし、迅速な意思決定を可能にします。

---

PURLは「パッケージの住所録」、SBOMは「構成部品のリスト」です。 この2つが揃って初めて、「攻撃されたパッケージ」と「自分たちの環境」を高速かつ正確に照合し、被害を最小化できます。サプライチェーン攻撃が常態化した今、これらは「あると便利」ではなく「ないと守れない」インフラになりつつあります。

## まとめ

PURL（Package URL）は、一言で言えばバラバラなパッケージ管理に「共通言語」をもたらす仕組みです。npmやPyPIといったエコシステムの壁を越えて一貫した識別ができるようになることで、SBOMや脆弱性管理は初めて実効性を持つようになります。

XZ UtilsやShai-Huludの事例が示すように、現代のサプライチェーン攻撃は「何が入っているか分からない」環境を狙います。SBOMで構成部品をリスト化し、PURLで一意に識別することで、脆弱性や汚染パッケージの影響範囲を瞬時に特定できます。

従来のCPEがOS・ハードウェア向けだったのに対し、PURLは開発者が日常的に使うパッケージマネージャの構造を反映しています。さらに `pkg:npm/left-pad@1.3.0` のように人間にも読みやすく、インシデント対応時のコミュニケーションミスを減らします。

「備えあれば憂いなし」というより、もはや「備えがないと戦えない」。サプライチェーン攻撃が日常化した今、PURLとSBOMの組み合わせは、現代のソフトウェア開発を支える「守りのインフラ」と言っても過言ではありません。

---
#### 余談
学部時代、家庭用IoT機器の脆弱性を調査する研究をしていました。その際、ブランドが異なる複数の製品に「全く同じOSSライブラリの、古いバージョン」が使い回されているのを見つけたことがあります。
ファイル構造から察するに、おそらく背後の製造元（OEM）が共通だったのでしょう。しかし、どのメーカーからもアップデートは提供されておらず、リスクが放置されたままでした。「メーカー自身、自社製品の中身を把握できていないのではないか？」……そんな危機感を抱いたのが、SBOMに興味を持ったきっかけです。
当時は「なぜこんな便利なものを使わないのか」と不思議でしたが、現実はそう単純ではありません。リストを作るだけでは不十分で、サプライヤー間の情報の断絶や、依存関係の深層まで追跡しきれないといった高い壁があります。これら「SBOM単体での運用」の課題を解決する手法を研究しています。

## 参考文献
- purl-spec / GitHub
https://github.com/package-url/purl-spec
- Annex F External repository identifiers (Normative) / SPDX Specification v2.3
https://spdx.github.io/spdx-spec/v2.3/external-repository-identifiers/#f35-purl
- XZ Utilsに悪意のあるコードが挿入された問題（CVE-2024-3094）について / JPCERT/CC 
https://www.jpcert.or.jp/newsflash/2024040101.html
- XZ Utilsにバックドアを仕込んだ謎の人物「Jia Tan」の正体とは？ 専門家たちの推理 / Wired Japan
https://wired.jp/article/jia-tan-xz-backdoor/
- Shai-Huludワームの復活は、25,000を超えるGitHubリポジトリに影響を及ぼす / Sysdig
https://www.sysdig.com/jp/blog/return-of-the-shai-hulud-worm-affects-over-25-000-github-repositories
- Shai-Hulud 2.0 Supply Chain Attack: 25K+ Repos Exposing Secrets / Wiz
https://www.wiz.io/blog/shai-hulud-2-0-ongoing-supply-chain-attack